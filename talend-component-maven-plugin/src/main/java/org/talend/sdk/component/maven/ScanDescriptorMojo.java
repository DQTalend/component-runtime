/**
 * Copyright (C) 2006-2019 Talend Inc. - www.talend.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.talend.sdk.component.maven;

import static java.util.Optional.ofNullable;
import static java.util.stream.Collectors.joining;
import static org.apache.maven.plugins.annotations.LifecyclePhase.PROCESS_CLASSES;
import static org.apache.maven.plugins.annotations.ResolutionScope.COMPILE_PLUS_RUNTIME;
import static org.talend.sdk.component.maven.api.Audience.Type.PUBLIC;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Properties;
import java.util.stream.Stream;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.xbean.finder.AnnotationFinder;
import org.apache.xbean.finder.archive.Archive;
import org.apache.xbean.finder.archive.ClasspathArchive;
import org.apache.xbean.finder.archive.CompositeArchive;
import org.apache.xbean.finder.filter.ExcludeIncludeFilter;
import org.apache.xbean.finder.filter.Filter;
import org.apache.xbean.finder.filter.Filters;
import org.apache.xbean.finder.filter.IncludeExcludeFilter;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.internationalization.Internationalized;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.service.Service;
import org.talend.sdk.component.api.service.http.Request;
import org.talend.sdk.component.maven.api.Audience;

/**
 * Pre-scan the components and services in current component.
 */
@Audience(PUBLIC)
@Mojo(name = "scan-descriptor", defaultPhase = PROCESS_CLASSES, requiresDependencyResolution = COMPILE_PLUS_RUNTIME,
        threadSafe = true)
public class ScanDescriptorMojo extends ClasspathMojoBase {

    @Parameter(defaultValue = "${project.build.outputDirectory}/TALEND-INF/scanning.properties",
            property = "talend.scan.output")
    private File output;

    @Parameter(property = "talend.scan.scannedDirectories")
    private Collection<File> scannedDirectories;

    @Parameter(property = "talend.scan.scannedDependencies")
    private Collection<String> scannedDependencies;

    @Parameter(property = "talend.scan.excludes")
    private List<String> excludes;

    @Parameter(property = "talend.scan.includes")
    private List<String> includes;

    @Parameter(property = "talend.scan.filter.strategy", defaultValue = "exclude-include")
    private String filterStrategy;

    @Override
    public void doExecute() throws MojoExecutionException {
        output.getParentFile().mkdirs();
        try (final OutputStream stream = new FileOutputStream(output)) {
            final Properties properties = new Properties();
            properties.setProperty("classes.list", scanList().collect(joining(",")));
            properties.store(stream, "generated by " + getClass() + " at " + new Date());
        } catch (final IOException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        }
    }

    private Stream<String> scanList() {
        final AnnotationFinder finder = newFinder();
        final Filter filter = newFilter();
        return Stream
                .concat(Stream
                        .of(PartitionMapper.class, Processor.class, Emitter.class, Service.class,
                                Internationalized.class)
                        .flatMap(it -> finder.findAnnotatedClasses(it).stream()),
                        Stream
                                .of(Request.class)
                                .flatMap(it -> finder.findAnnotatedMethods(it).stream())
                                .map(Method::getDeclaringClass))
                .distinct()
                .map(Class::getName)
                .filter(filter::accept);
    }

    private Filter newFilter() {
        final Filter accept = ofNullable(includes)
                .filter(it -> it.size() > 0)
                .map(i -> i.toArray(new String[0]))
                .map(Filters::patterns)
                .orElseGet(() -> name -> true);
        final Filter reject = ofNullable(excludes)
                .filter(it -> it.size() > 0)
                .map(i -> i.toArray(new String[0]))
                .map(Filters::patterns)
                .orElseGet(() -> name -> false);
        if ("include-exclude".equals(filterStrategy)) {
            return new IncludeExcludeFilter(accept, reject);
        }
        return new ExcludeIncludeFilter(accept, reject);
    }

    private AnnotationFinder newFinder() {
        return new AnnotationFinder(
                new CompositeArchive(Stream.concat(getDirectoriesToScan(), getJarToScan()).map(c -> {
                    try {
                        return ClasspathArchive
                                .archive(Thread.currentThread().getContextClassLoader(), c.toURI().toURL());
                    } catch (final MalformedURLException e) {
                        throw new IllegalArgumentException(e);
                    }
                }).toArray(Archive[]::new)));
    }

    private Stream<File> getJarToScan() {
        if (scannedDependencies == null || scannedDependencies.isEmpty()) {
            return Stream.empty();
        }
        return scannedDependencies
                .stream()
                .map(it -> project
                        .getArtifacts()
                        .stream()
                        .filter(art -> it.equals(art.getGroupId() + ':' + art.getArtifactId()))
                        .findFirst()
                        .orElse(null))
                .filter(Objects::nonNull)
                .map(Artifact::getFile)
                .filter(Objects::nonNull);
    }

    private Stream<File> getDirectoriesToScan() {
        return scannedDirectories == null || scannedDirectories.isEmpty() ? Stream.of(classes)
                : scannedDirectories.stream();
    }
}
