<#--
  Copyright (C) 2006-2017 Talend Inc. - www.talend.com
   Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
//
// This class was generated by talend component maven plugin
//
<#if definition.packageName?has_content>
package ${definition.packageName};
</#if>

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.avro.Schema;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;
import org.talend.components.api.component.runtime.Result;
import org.talend.components.api.component.runtime.Sink;
import org.talend.components.api.component.runtime.WriteOperation;
import org.talend.components.api.component.runtime.Writer;
import org.talend.components.api.component.runtime.WriterWithFeedback;
import org.talend.components.api.container.RuntimeContainer;
import org.talend.components.api.properties.ComponentProperties;
import org.talend.component.runtime.avro.ComponentModelToIndexeredRecordConverter;
import org.talend.component.runtime.di.AutoChunkProcessor;
import org.talend.component.runtime.manager.ComponentManager;
import org.talend.component.runtime.manager.processor.SubclassesCache;
import org.talend.component.runtime.output.Branches;
import org.talend.component.runtime.serialization.LightContainer;
import org.talend.daikon.NamedThing;
import org.talend.daikon.properties.ValidationResult;

import ${propertiesType};

public class ${definition.className}Sink implements Sink {
    private ${shortPropertiesType} rootProperties;

    @Override
    public WriteOperation<?> createWriteOperation() {
        final Map<String, String> $$preparedConfiguration = new HashMap<>();
        <#list parameters as key, value>
        if (<#list value.conditions as condition>${condition}<#sep> && </#sep></#list>) {
            <#if key?ends_with("[]")>
            IntStream.range(0, ${value.value}.size()).forEach(index -> $$preparedConfiguration.put("${key?remove_ending("[]")}[" + index + "]", ${value.value}.get(index)));
            <#else>
            $$preparedConfiguration.put("${key}", ${value.value});
            </#if>
        }
        </#list>
        final int chunkSize = rootProperties.$$internalChunkSize.getValue();
        return new ${definition.className}Operation(this, $$preparedConfiguration, chunkSize);
    }

    @Override
    public List<NamedThing> getSchemaNames(final RuntimeContainer container) throws IOException {
        return null;
    }

    @Override
    public Schema getEndpointSchema(final RuntimeContainer container, final String schemaName) throws IOException {
        return null;
    }

    @Override
    public ValidationResult validate(final RuntimeContainer container) {
        return ValidationResult.OK;
    }

    @Override
    public ValidationResult initialize(final RuntimeContainer container, final ComponentProperties properties) {
        this.rootProperties = ${shortPropertiesType}.class.cast(properties);
        return ValidationResult.OK;
    }

    private static ComponentManager manager() {
        final ComponentManager instance = ComponentManager.instance();
        synchronized (instance) {
            if (!instance.findPlugin("${plugin}").isPresent()) {
                instance.addPlugin("${plugin}");
            }
        }
        return instance;
    }

    public static ClassLoader componentClassLoader() { // helper for definition
        return manager().findPlugin("${plugin}").orElseThrow(() -> new IllegalArgumentException("No plugin '${plugin}'")).getLoader();
    }

    public static class ${definition.className}Operation implements WriteOperation<Result> {

        private final ${definition.className}Sink sink;

        private final Map<String, String> configuration;

        private final int chunkSize;

        public ${definition.className}Operation(final ${definition.className}Sink sink, final Map<String, String> configuration, final int chunkSize) {
            this.sink = sink;
            this.configuration = configuration;
            this.chunkSize = chunkSize;
        }

        @Override
        public Writer<Result> createWriter(final RuntimeContainer adaptor) {
            return new ${definition.className}Writer(this, configuration, chunkSize);
        }

        @Override
        public void initialize(final RuntimeContainer adaptor) {
            // no-op
        }

        @Override
        public Map<String, Object> finalize(final Iterable<Result> writerResults, final RuntimeContainer adaptor) {
            return Result.accumulateAndReturnMap(writerResults);
        }

        @Override
        public Sink getSink() {
            return sink;
        }
    }

    public static class ${definition.className}Writer implements WriterWithFeedback<Result, IndexedRecord, IndexedRecord> {

        private final ${definition.className}Operation operation;

        private final Map<String, String> configuration;

        private final Result result = new Result();

        private final int chunkSize;

        private final ComponentModelToIndexeredRecordConverter recordConverter;

        private final SubclassesCache subclassCache;

        private final Class<?> recordType;

        private AutoChunkProcessor processor;

        private Iterable<IndexedRecord> main;

        private Iterable<IndexedRecord> reject;

        public ${definition.className}Writer(final ${definition.className}Operation ${definition.className}Operation, final Map<String, String> configuration, final int chunkSize) {
            this.configuration = configuration;
            this.operation = ${definition.className}Operation;
            this.chunkSize = chunkSize;
            this.recordConverter = new ComponentModelToIndexeredRecordConverter();
            this.subclassCache = ComponentManager.instance()
                        .findPlugin("${plugin}")
                        .orElseThrow(() -> new IllegalArgumentException("No plugin '${plugin}'"))
                        .get(LightContainer.class).findService(SubclassesCache.class);
            try {
                this.recordType = componentClassLoader().loadClass("${recordType}");
            } catch (final ClassNotFoundException e) {
                throw new IllegalArgumentException(e);
            }
        }

        @Override
        public Iterable<IndexedRecord> getSuccessfulWrites() {
            return main == null ? emptyList() : main;
        }

        @Override
        public Iterable<IndexedRecord> getRejectedWrites() {
            return reject == null ? emptyList() : reject;
        }

        @Override
        public void open(final String uId) throws IOException {
            processor = new AutoChunkProcessor(chunkSize, manager().findProcessor("${family}", "${name}", ${version}, configuration)
                    .orElseThrow(() -> new IllegalArgumentException("No component ${family}#${name}")));
            processor.start();
        }

        @Override
        public void write(final Object object) throws IOException {
            try {
                processor.onElement(branch -> {
                    <#if recordType == "org.apache.avro.generic.IndexedRecord">
                    return object;
                    <#else>
                    return recordConverter.reverseMapping(subclassCache, IndexedRecord.class.cast(object), recordType);
                    </#if>
                }, branch -> {
                    if (!Branches.DEFAULT_BRANCH.equals(branch)) {
                        return o -> reject = singletonList(toIR(o));
                    }
                    return o -> main = singletonList(toIR(o));
                });
                result.successCount++;
            } catch (final RuntimeException re) {
                try {
                    reject = singletonList(toIR(object));
                } catch (final RuntimeException unexpected) {
                    reject = singletonList(new GenericData.Record(Schema.createRecord(getClass().getName() + "$Unexpected", null, getClass().getName() + ".namespace", false)));
                }
                result.rejectCount++;
            } finally {
                result.totalCount++;
            }
        }

        @Override
        public Result close() throws IOException {
            processor.stop();
            return result;
        }

        @Override
        public WriteOperation<Result> getWriteOperation() {
            return operation;
        }

        private IndexedRecord toIR(final Object o) {
            return IndexedRecord.class.isInstance(o) ? IndexedRecord.class.cast(o) : recordConverter.map(o);
        }
    }
}
