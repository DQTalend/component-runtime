<#--
  Copyright (C) 2006-2017 Talend Inc. - www.talend.com
   Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
//
// This class was generated by talend component maven plugin
//
<#if definition.packageName?has_content>
package ${definition.packageName};
</#if>

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.IntStream;

import org.apache.avro.Schema;
import org.apache.avro.generic.IndexedRecord;
import org.talend.components.api.component.runtime.AbstractBoundedReader;
import org.talend.components.api.component.runtime.BoundedReader;
import org.talend.components.api.component.runtime.BoundedSource;

import org.talend.components.api.component.runtime.Result;
import org.talend.components.api.container.RuntimeContainer;
import org.talend.components.api.properties.ComponentProperties;
import org.talend.sdk.component.runtime.avro.ComponentModelToIndexeredRecordConverter;
import org.talend.sdk.component.runtime.input.Input;
import org.talend.sdk.component.runtime.manager.ComponentManager;
import org.talend.sdk.component.runtime.input.Mapper;
import org.talend.daikon.NamedThing;
import org.talend.daikon.properties.ValidationResult;

import ${propertiesType};

public class ${definition.className} implements BoundedSource {
    private Mapper mapper;

    @Override
    public ValidationResult initialize(final RuntimeContainer container, final ComponentProperties properties) {
        final ${shortPropertiesType} rootProperties = ${shortPropertiesType}.class.cast(properties);
        final ComponentManager manager = ComponentManager.instance();
        synchronized (manager) {
            if (!manager.findPlugin("${plugin}").isPresent()) {
                manager.addPlugin("${plugin}");
            }
        }
        mapper = manager.findMapper("${family}", "${name}", ${version}, new HashMap<String, String>() {
                    {<#list parameters as key, value>
                        if (<#list value.conditions as condition>${condition}<#sep> && </#sep></#list>) {
                            <#if key?ends_with("[]")>
                            IntStream.range(0, ${value.value}.size()).forEach(index -> put("${key?remove_ending("[]")}[" + index + "]", ${value.value}.get(index)));
                            <#else>
                            put("${key}", ${value.value});
                            </#if>
                        }
                    </#list>}
                }).orElseThrow(() -> new IllegalArgumentException("Didn't find component ${family}#${name} component"));
        return ValidationResult.OK;
    }

    @Override
    public ValidationResult validate(final RuntimeContainer container) {
        mapper.start();
        try {
            mapper.start();
            return ValidationResult.OK;
        } catch (final RuntimeException re) {
            return new ValidationResult(ValidationResult.Result.ERROR, re.getMessage());
        } finally {
            mapper.stop();
        }
    }

    @Override
    public long getEstimatedSizeBytes(final RuntimeContainer adaptor) {
        mapper.start();
        try {
            return mapper.assess();
        } finally {
            mapper.stop();
        }
    }

    @Override
    public List<? extends BoundedSource> splitIntoBundles(final long desiredBundleSizeBytes, final RuntimeContainer adaptor)
            throws Exception {
        mapper.start();
        try {
            final List<Mapper> split = mapper.split(desiredBundleSizeBytes);
            if (split.isEmpty()) {
                return emptyList();
            }
            if (split.size() == 1 && split.get(0) == mapper) {
                return singletonList(this);
            }
            return null;
        } finally {
            mapper.stop();
        }
    }

    @Override
    public BoundedReader<IndexedRecord> createReader(final RuntimeContainer adaptor) {
        mapper.start();
        try {
            return new InputBoundedReader(this, mapper.create());
        } finally {
            mapper.stop();
        }
    }

    @Override
    public boolean producesSortedKeys(final RuntimeContainer adaptor) {
        return false;
    }

    @Override
    public List<NamedThing> getSchemaNames(final RuntimeContainer container) throws IOException {
        return null;
    }

    @Override
    public Schema getEndpointSchema(final RuntimeContainer container, final String schemaName) throws IOException {
        return null;
    }

    private static class InputBoundedReader extends AbstractBoundedReader<IndexedRecord> {

        private final Input delegate;
        private final ComponentModelToIndexeredRecordConverter recordConverter;

        private Result result; // not doing much yet
        private Object current;

        private InputBoundedReader(final BoundedSource source, final Input input) {
            super(source);
            this.delegate = input;
            this.recordConverter = new ComponentModelToIndexeredRecordConverter();
        }

        @Override
        public IndexedRecord getCurrent() throws NoSuchElementException {
            if (current == null) {
                throw new NoSuchElementException("No element to return, ensure you called start() or advance() and it returned true");
            }
            return recordConverter.map(current);
        }

        @Override
        public boolean start() throws IOException {
            delegate.start();
            this.result = new Result();
            return advance();
        }

        @Override
        public boolean advance() throws IOException {
            current = delegate.next();
            return current != null;
        }

        @Override
        public Map<String, Object> getReturnValues() {
            return result == null ? emptyMap() : result.toMap();
        }

        @Override
        public void close() throws IOException {
            delegate.stop();
        }
    }
}
