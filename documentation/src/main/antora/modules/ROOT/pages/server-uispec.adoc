= UiSpec Server

The UiSpec server is a companion application for the Component Server.
It provides a client to the Component Server which serves UiSpec payload to integrate
with the client Javascript `UiForm` library.

== Coordinates

[source,xml]
----
<dependency>
  <groupId>org.talend.sdk.component</groupId>
  <artifactId>component-server-proxy</artifactId>
  <version>${server-proxy.version}</version>
</dependency>
----

== Configuration

include::{partialsdir}/generated_proxy-server-configuration.adoc[]

=== Dropdown with all root configurations

TIP: the special `dynamic_values` action `builtin::roots` can be used for a drop down which will
be filled with all available root types.

Here is a sample patch file:

[source,json]
----
{
  "properties": [
    {
      "path": "_datasetMetadata",
      "type": "OBJECT"
    },
    {
      "path": "_datasetMetadata.type",
      "displayName": "Types",
      "type": "ENUM",
      "metadata": {
        "action::dynamic_values": "builtin::roots"
      }
    }
  ]
}
----

=== Reload the form based on the selected root

As a companion of previous action there is the `builtin::root::reloadFromId` action of type `jsonpatch` which
allows to reload the whole form:

[source,json]
----
{
  "path": "_datasetMetadata.type",
  "displayName": "Types",
  "type": "STRING",
  "metadata": {
    "action::dynamic_values": "builtin::roots", <1>
    "action::reloadForm": "builtin::root::reloadFromId", <2>
    "action::reloadForm::parameters": "."
  }
}
----

<1> Prepopulate the dropdown with the list of datastore
<2> On the selection of a datastore refresh the form with the new parameters

Here we use both to have a dropdown with the list of roots and to reload the form when one is selected.

Here is how the `UIForm` (javascript side) part can be implemented:

[source,javascript]
----
import kit from 'component-kit.js';

// ...

constructor(props) {
  super(props);

  this.state = {};
  this.trigger = kit.createTriggers({
    url: '/componentproxy/api/v1/actions/execute',
    customRegistry: {
      reloadForm: ({ body }) => { <1>
        const { _datasetMetadata } = this.state.uiSpec.properties;
        return {
          ...body, <2>
          properties: { _datasetMetadata }, <3>
        };
      }
    }
  });


  // ...
  }

// ...

onTrigger(event, payload) {
  return this.trigger(event, payload)
    .then(result => {
      if (result.properties || result.errors || result.uiSchema || result.jsonSchema) { <4>
        this.setState({
          uiSpec: {
            ...this.state.uiSpec,
            ...result,
          }
        });
      }
    });
}
----

<1> Add a custom handler for the specific `reloadForm` action
<2> Pass the `uiSchema` and `jsonSchema` back to the next step in the response processing chain
<3> Reset the dynamic part of the form (= keep only the static part)
<4> Merge back the result of the handler into the current state (you can use redux or cmf as well)

== HTTP API

include::{partialsdir}/generated_proxy-server-api.adoc[]

== Play Integration

Thanks to https://github.com/rmannibucau/playx[Playx] you can deploy this server
in a Play! application.

The first step is to import the play integration (which mainly imports pre-configuration):

[source,xml]
----
<dependency>
  <groupId>org.talend.sdk.component</groupId>
  <artifactId>component-server-proxy-play</artifactId>
  <version>${server-proxy.version}</version>
</dependency>
----

Then you can configure it in your `application.conf` - see configuration for more details:

[source,config]
----
include "conf/component-proxy.play.conf" <1>

talend.component.proxy { <2>
  server {
    base = "http://localhost:8080/api/v1"
  }
  processing {
    headers = """
X-ServiceName = proxy
X-ID = ${someRequestAttributeNameForTheId}
"""
    // ...
  }
}
----

<1> Imports the global configuration mapping the endpoints on `/componentproxy/*`
<2> Customize the configuration to specialize it for the current deployment

=== If you are using Guice

`org.talend.sdk.component.proxy.guice.ComponentUiSpecServerModule` Guice module allows
to import `Services` from the server and to use some of them locally for the part
out of scope of the endpoint delivery like:

- Converting `JsonObject` to `Map<String, String>` and the opposite
- Getting the properties model for a configuration or component (used in previous item)

IMPORTANT: it is important to use a `Provider<T>` injection to keep it lazy.
